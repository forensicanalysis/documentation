[{"body":"\"This documentation supports the artifactcollector and elementary command line tools, forensicstores and the related libraries.\\nWhile the artifactcollector can be run without special IT expertise the elementary tooling and this documentation is aimed at forensicators, incident responders and analysts.\\nThe code and API documentation is linked in the corresponding GitHub repositories. For questions you can use GitHub or the Open Source DFIR Slack.\\nThis documentation is splitted into an usage sections for users of the provided tools and a development section for people that want to customize or extent the tools.\\n\"","section":"The elementary documentation","summary":"This documentation supports the artifactcollector and elementary command line tools, forensicstores and the related libraries.\nWhile the artifactcollector can be run without special IT expertise the elementary tooling and this documentation is aimed at forensicators, incident responders and analysts.\nThe code and API documentation is linked in the corresponding GitHub repositories. For questions you can use GitHub or the Open Source DFIR Slack.\nThis documentation is splitted into an usage sections for users of the provided tools and a development section for people that want to customize or extent the tools.","tags":[],"title":"The elementary documentation","url":"/documentation/docs/"},{"body":"\"   The elementary tools can be used as an entry point for your analysis. Always double check your results.     The elementary workflow The elementary workflow (not to be confused with the elementary workflow command) is centered around the forensicstore database file. The forensicstore can be created using either the artifactcollector on a live system or from a disk image.\\nThis forensicstore can be processed using elementary afterwards to create reports to investigate e.g. connected usb devices or persistent software.\\ngraph LR;\\rA[Live System] --|artifactcollector| B(forensicstore)\\rG[Disk Image] --|elementary run import-image| B(forensicstore)\\rB --|elementary run x| D[Report]\\r\\r\"","section":"Usage","summary":"The elementary tools can be used as an entry point for your analysis. Always double check your results.     The elementary workflow The elementary workflow (not to be confused with the elementary workflow command) is centered around the forensicstore database file. The forensicstore can be created using either the artifactcollector on a live system or from a disk image.\nThis forensicstore can be processed using elementary afterwards to create reports to investigate e.","tags":[],"title":"Usage","url":"/documentation/docs/usage/"},{"body":"\"   The artifactcollector behaves similar to malware and might be detected as a virus or malware.     What is the artifactcollector? The artifactcollector is a tool to collect forensic artifacts on a system. It can be used in forensic investigations to extract specific data instead of creating full disk images.\\nThe artifactextractor can collect low-level (like $MFT) and high-level file artifacts as well as registry keys (e.g. run keys) which can then be used in forensic investigations.\\nThe artifactcollector is a single binary that can be transferred to computers which are part of a forensic investigation.\\nDownload All releases of the artifactcollector can be downloaded from https://github.com/forensicanalysis/artifactcollector/releases. Prebuild artifactcollectors for Windows, Linux and macOS are availabe. Those artifactcollectors collect a predefined set of artifacts which are mostly taken from the Sans FOR500 training. Sans provides a comprehensive poster explaining those artifacts.\\nUsage On Windows the artifactcollector.exe can be executed by double clicking it on the investigated machine. The user will be provided with a UAC prompt because the artifactcollector required administrator rights to run. The collection takes somes minutes, depending on processing power and contained artifacts.\\nOn Linux and macOS the artifactcollector needs to be executed as root, e.g. sudo artifactcollector. macOS can still prevent the execution, in this case right click the artifactcollector, select \\u0026ldquo;Open\\u0026rdquo;, confirm \\u0026ldquo;Open\\u0026rdquo; and afterwards try again with sudo artifactcollector.\\nThe artifactcollecor will create a .forensicstore file and a log file. The log file serves two purposes: inform an investigator about errors during the collection but also give the user a wayto know what elements were extracted. The forensicstore contains the results of the extraction and needs to be transferred back to the investigator.\\n\"","section":"Usage","summary":"The artifactcollector behaves similar to malware and might be detected as a virus or malware.     What is the artifactcollector? The artifactcollector is a tool to collect forensic artifacts on a system. It can be used in forensic investigations to extract specific data instead of creating full disk images.\nThe artifactextractor can collect low-level (like $MFT) and high-level file artifacts as well as registry keys (e.","tags":[],"title":"Acquisition / artifactcollector","url":"/documentation/docs/usage/acquisition/"},{"body":"\"Elementary is a command line tool that can create and process forensicstore files.\\nUnpack forensicstores To extract all file artifacts stored in the forensicstore you can use:\\nelementary archive unpack TestMachine.forensicstore\\rMore examples:\\n# Extract all prefetch files\\relementary archive unpack --match \\u0026#34;*.pf\\u0026#34; TestMachine.forensicstore\\r# Extract all windows eventlogs recreateing the original folder structure\\relementary archive unpack --match \\u0026#34;*.evtx\\u0026#34; --mode folder \\\\ \\r--prefix-artifact=false TestMachine.forensicstore\\rRun The elementary command line tool can run single commands, e.g.:\\nelementary run usb TestMachine.forensicstore\\r\"","section":"Usage","summary":"Elementary is a command line tool that can create and process forensicstore files.\nUnpack forensicstores To extract all file artifacts stored in the forensicstore you can use:\nelementary archive unpack TestMachine.forensicstore\rMore examples:\n# Extract all prefetch files\relementary archive unpack --match \u0026#34;*.pf\u0026#34; TestMachine.forensicstore\r# Extract all windows eventlogs recreateing the original folder structure\relementary archive unpack --match \u0026#34;*.evtx\u0026#34; --mode folder \\ \r--prefix-artifact=false TestMachine.forensicstore\rRun The elementary command line tool can run single commands, e.","tags":[],"title":"Processing / elementary","url":"/documentation/docs/usage/processing/"},{"body":"\"Different organizations and investigations require flexible tools that can be targeted to most cases, therefore the artifactcollector and elementary provide options for customization and extension to handle as many cases as possible.\\n\"","section":"Development","summary":"Different organizations and investigations require flexible tools that can be targeted to most cases, therefore the artifactcollector and elementary provide options for customization and extension to handle as many cases as possible.","tags":[],"title":"Development","url":"/documentation/docs/development/"},{"body":"\"Collect a custom set of artifacts  Clone the repository git clone https://github.com/forensicanalysis/artifactcollector. Run go generate to download all artifacts. Add artifact definition yaml files as needed in pack/artifacts. Do not edit the artifact definitions, as they will be overwritten. Edit pack/ac.yaml and add the artifacts you want to collect. Run go generate. This might yield some errors or problems in your artifacts. On windows you can move the syso into the root folder (e.g. cp resources\\\\artifactcollector.syso .) to enable the icon for the executable and the UAC popup. Run go build . to generates an executable.  Embed binaries Binaries can be added to pack/bin and than included into the artifactcollector in the go generate step. Additionally a corresponding COMMAND artifact like the following is required.\\nname: Autoruns\\rsources:\\r- type: COMMAND\\rattributes:\\rcmd: autorunsc.exe\\rargs: [\\u0026#34;-x\\u0026#34;, \\u0026#34;-accepteula\\u0026#34;]\\rsupported_os: [Windows]\\rCurrently the output to stdout and stderr is saved, but generated files are not collected.\\n\"","section":"Development","summary":"Collect a custom set of artifacts  Clone the repository git clone https://github.com/forensicanalysis/artifactcollector. Run go generate to download all artifacts. Add artifact definition yaml files as needed in pack/artifacts. Do not edit the artifact definitions, as they will be overwritten. Edit pack/ac.yaml and add the artifacts you want to collect. Run go generate. This might yield some errors or problems in your artifacts. On windows you can move the syso into the root folder (e.","tags":[],"title":"Collect custom artifacts","url":"/documentation/docs/development/customize/"},{"body":"\"Artifact definition files The artifact definition format is described in detail in the Style Guide. The following shows an example for an artifact definition file. It defines the location of linux audit log files on a system.\\nname: LinuxAuditLogFiles doc: Linux audit log files. sources: - type: FILE attributes: {paths: [\\u0026#39;/var/log/audit/*\\u0026#39;]} supported_os: [Linux] We use https://github.com/forensicanalysis/artifacts as the main repository for forensic artifacts definitions.\\n\"","section":"Development","summary":"Artifact definition files The artifact definition format is described in detail in the Style Guide. The following shows an example for an artifact definition file. It defines the location of linux audit log files on a system.\nname: LinuxAuditLogFiles doc: Linux audit log files. sources: - type: FILE attributes: {paths: [\u0026#39;/var/log/audit/*\u0026#39;]} supported_os: [Linux] We use https://github.com/forensicanalysis/artifacts as the main repository for forensic artifacts definitions.","tags":[],"title":"Define Artifacts","url":"/documentation/docs/development/artifacts/"},{"body":"\"Cross compilation is a bit more difficult, as a cross compiler like MinGW is required by CGO.\\nExample cross compilation for Windows:\\nCGO_ENABLED=1 CC=i686-w64-mingw32-gcc GOOS=windows GOARCH=386 go build . CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc GOOS=windows GOARCH=amd64 go build . \"","section":"Development","summary":"Cross compilation is a bit more difficult, as a cross compiler like MinGW is required by CGO.\nExample cross compilation for Windows:\nCGO_ENABLED=1 CC=i686-w64-mingw32-gcc GOOS=windows GOARCH=386 go build . CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc GOOS=windows GOARCH=amd64 go build . ","tags":[],"title":"Cross compilation","url":"/documentation/docs/development/cross/"},{"body":"\"A forensicstore is a forensic database that contains selected forensic artifacts.\\nThe forensicstore format The forensicstore format implements the following conventions:\\n The forensicstore is a sqlite database containing metadata element and compressed raw artifacts. Elements are represented as json objects. Elements are valid STIX 2.1 Observable Objects where applicable. Elements must not have dots (\\u0026quot;.\\u0026quot;) in their json keys. Files stored in the forensicstore are referenced by element attributes ending in _path, e.g. export_path, stdout_path and wmi_path. Element attributes ending in _time or named atime, ctime or mtime are assumed to be dates and should be stored according RFC3339/ISO 8601. Any element stored in the forensicstore can have an errors attribute that contains errors that are related to retrival or processing of this element. Raw artifacts are stored using the deflate compression algorithm.  \"","section":"Development","summary":"A forensicstore is a forensic database that contains selected forensic artifacts.\nThe forensicstore format The forensicstore format implements the following conventions:\n The forensicstore is a sqlite database containing metadata element and compressed raw artifacts. Elements are represented as json objects. Elements are valid STIX 2.1 Observable Objects where applicable. Elements must not have dots (\u0026quot;.\u0026quot;) in their json keys. Files stored in the forensicstore are referenced by element attributes ending in _path, e.","tags":[],"title":"Forensicstore","url":"/documentation/docs/development/forensicstore/"},{"body":"\"Command types There are three commands types: Built-in Go Commands, Docker Commands or Script Commands.\\nBuilt-in command elementary contains some builtin commands. Those cannot be dynamically extended via plugins.\\nDocker commands Docker commands utilize installed docker images. Those images need to be named xxx/elementary-yyy. elementary loads some image on startup but also handles other images matching the naming schema.\\nScript commands Script commands are rum from the config dir. The config is located at:\\n $XDG_CONFIG_HOME/elementary or $HOME/.config/elementary for Unix systems $HOME/Library/Application Support/elementary on macOS %AppData%/elementary on Windows  The script needs to be prefixed with elementary, e.g. elementary-runkeys.py. elementary installs some scripts on startup but also handles other scripts matching the naming schema.\\n\"","section":"Development","summary":"Command types There are three commands types: Built-in Go Commands, Docker Commands or Script Commands.\nBuilt-in command elementary contains some builtin commands. Those cannot be dynamically extended via plugins.\nDocker commands Docker commands utilize installed docker images. Those images need to be named xxx/elementary-yyy. elementary loads some image on startup but also handles other images matching the naming schema.\nScript commands Script commands are rum from the config dir. The config is located at:","tags":[],"title":"Plugins","url":"/documentation/docs/development/plugins/"},{"body":"\"Contact For feedback, questions and discussions you can use the Open Source DFIR Slack.\\n\"","section":"","summary":"Contact For feedback, questions and discussions you can use the Open Source DFIR Slack.","tags":[],"title":"","url":"/documentation/"},{"body":"\"\"","section":"","summary":"","tags":[],"title":"Categories","url":"/documentation/categories/"},{"body":"\"\"","section":"","summary":"","tags":[],"title":"Tags","url":"/documentation/tags/"}]