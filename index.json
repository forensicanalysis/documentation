[{"body":"\"This documentation supports the artifactcollector and elementary command line tools, forensicstores and the related libraries.\\nWhile the artifactcollector can be run without special IT expertise the elementary tooling and this documentation is aimed at forensicators, incident responders and analysts.\\nThe code and API documentations are linked in the corresponding GitHub repositories. For questions you can use GitHub or the Open Source DFIR Slack.\\nThis documentation is splitted into an usage sections for users of the provided tools and a development section for people that want to customize or extent the tools.\\n\"","section":"The elementary documentation","summary":"This documentation supports the artifactcollector and elementary command line tools, forensicstores and the related libraries.\nWhile the artifactcollector can be run without special IT expertise the elementary tooling and this documentation is aimed at forensicators, incident responders and analysts.\nThe code and API documentations are linked in the corresponding GitHub repositories. For questions you can use GitHub or the Open Source DFIR Slack.\nThis documentation is splitted into an usage sections for users of the provided tools and a development section for people that want to customize or extent the tools.","tags":[],"title":"The elementary documentation","url":"/documentation/manual/"},{"body":"\"\"","section":"Home","summary":"","tags":[],"title":"Home","url":"/documentation/"},{"body":"\"   The elementary tools can be used as an entry point for your analysis. Always double check your results.     The elementary workflow The elementary workflow (not to be confused with the elementary workflow command) is centered around the forensicstore database file. The forensicstore can be created using either the artifactcollector on a live system or from a disk image.\\nThis forensicstore can be processed using elementary afterwards to create reports to investigate e.g. connected usb devices or persistent software.\\ngraph LR; A[Live System] --|artifactcollector| B(forensicstore) G[Disk Image] --|elementary run import-image| B(forensicstore) B --|elementary run x| D[Report]  \"","section":"Usage","summary":"The elementary tools can be used as an entry point for your analysis. Always double check your results.     The elementary workflow The elementary workflow (not to be confused with the elementary workflow command) is centered around the forensicstore database file. The forensicstore can be created using either the artifactcollector on a live system or from a disk image.\nThis forensicstore can be processed using elementary afterwards to create reports to investigate e.","tags":[],"title":"Usage","url":"/documentation/manual/usage/"},{"body":"\"   The artifactcollector behaves like malware as it collects critical system files and might be detected as a virus or malware.     What is the artifactcollector? The artifactcollector is a tool to collect forensic artifacts on a system. It can be used in forensic investigations to extract specific data instead of creating full disk images. The artifactextractor can collect low-level (like $MFT) and high-level file artifacts as well as registry keys (e.g. run keys) which can then be used in forensic investigations.\\nFigure 1. Running the artifactextractor on Windows.\\nThe artifactcollector is a single binary that can be transferred to computers which are part of a forensic investigation.\\nDownload All releases of the artifactcollector can be downloaded from GitHub. Prebuild artifactcollectors for Windows, Linux and macOS are availabe. Those artifactcollectors collect a predefined set of artifacts which are mostly taken from the Sans FOR500 training. Sans provides a comprehensive poster explaining those artifacts.\\nUsage On Windows the artifactcollector.exe can be executed by double clicking it on the investigated machine. The user will be provided with a UAC prompt because the artifactcollector required administrator rights to run. The collection takes some minutes, depending on processing power and contained artifacts.\\nOn Linux and macOS the artifactcollector needs to be executed as root, e.g. sudo artifactcollector. macOS can still prevent the execution, in this case right click the artifactcollector, select \\u0026ldquo;Open\\u0026rdquo;, confirm \\u0026ldquo;Open\\u0026rdquo; and afterwards try again with sudo artifactcollector.\\nOutput The artifactcollecor will create a .forensicstore file and a log file. The log file serves two purposes: inform an investigator about errors during the collection but also give the user a way to know what elements were extracted. The forensicstore contains the results of the extraction and needs to be transferred back to the investigator.\\n\"","section":"Usage","summary":"The artifactcollector behaves like malware as it collects critical system files and might be detected as a virus or malware.     What is the artifactcollector? The artifactcollector is a tool to collect forensic artifacts on a system. It can be used in forensic investigations to extract specific data instead of creating full disk images. The artifactextractor can collect low-level (like $MFT) and high-level file artifacts as well as registry keys (e.","tags":[],"title":"Acquisition with the artifactcollector","url":"/documentation/manual/usage/acquisition/"},{"body":"\"Elementary is a command line tool that can create and process forensicstore files.\\nUnpack forensicstores To extract all file artifacts stored in the forensicstore you can use:\\nelementary archive unpack TestMachine.forensicstore More examples:\\n# Extract all prefetch files elementary archive unpack --match \\u0026#34;*.pf\\u0026#34; TestMachine.forensicstore # Extract all windows eventlogs recreateing the original folder structure elementary archive unpack --match \\u0026#34;*.evtx\\u0026#34; --mode folder \\\\  --prefix-artifact=false TestMachine.forensicstore Run forensic tasks The elementary command line tool can run single commands, e.g.:\\nelementary run usb TestMachine.forensicstore \"","section":"Usage","summary":"Elementary is a command line tool that can create and process forensicstore files.\nUnpack forensicstores To extract all file artifacts stored in the forensicstore you can use:\nelementary archive unpack TestMachine.forensicstore More examples:\n# Extract all prefetch files elementary archive unpack --match \u0026#34;*.pf\u0026#34; TestMachine.forensicstore # Extract all windows eventlogs recreateing the original folder structure elementary archive unpack --match \u0026#34;*.evtx\u0026#34; --mode folder \\  --prefix-artifact=false TestMachine.forensicstore Run forensic tasks The elementary command line tool can run single commands, e.","tags":[],"title":"Processing with elementary","url":"/documentation/manual/usage/processing/"},{"body":"\"Different organizations and investigations require flexible tools that can be targeted to most cases, therefore the artifactcollector and elementary provide options for customization and extension to handle as many cases as possible.\\n\"","section":"Development","summary":"Different organizations and investigations require flexible tools that can be targeted to most cases, therefore the artifactcollector and elementary provide options for customization and extension to handle as many cases as possible.","tags":[],"title":"Development","url":"/documentation/manual/development/"},{"body":"\"Forensic investigations differ and investigators have different approaches in forensic cases. The artifactcollector can cater to these needs by collecting a different set of artifacts related to the situation.\\nCollect a custom set of artifacts  Clone the repository git clone https://github.com/forensicanalysis/artifactcollector. Run go generate to download all artifacts. Add artifact definition yaml files as needed in pack/artifacts. Do not edit the artifact definitions, as they will be overwritten. Edit pack/ac.yaml and add the artifacts you want to collect. Run go generate. This might yield some errors or problems in your artifacts. On windows you can move the syso into the root folder (e.g. cp resources\\\\artifactcollector.syso .) to enable the icon for the executable and the UAC popup. Run go build . to generates an executable.  Define artifacts A structured way to define forensic artifacts was introduced by Google in development of the grr endpoint client: https://github.com/ForensicArtifacts/artifacts. We use the forked https://github.com/forensicanalysis/artifacts as the main repository for forensic artifacts definitions, because the main project contains some issues.\\nThe artifacts are yaml documents that define different types of forensic artifacts:\\n Paths Directories Files Registry Keys and Values WMI Queries Command execution  Letâ€™s have a look at an artifact definition for Windows Prefetch files. The artifact defines the location of the prefetch files on Windows.\\nname: WindowsPrefetchFiles doc: Windows Prefetch files. sources: - type: FILE attributes: paths: [\\u0026#39;%%environ_systemroot%%\\\\Prefetch\\\\*.pf\\u0026#39;] separator: \\u0026#39;\\\\\\u0026#39; labels: [System] supported_os: [Windows] urls: [\\u0026#39;http://www.forensicswiki.org/wiki/Prefetch\\u0026#39;] If added to the artifactcollector and included in the configuration file, the artifactcollector would collect all .pf files in %%environ_systemroot%%\\\\Prefetch. The %%environ_systemroot%% variable is replaced by the artifactcollector using the WindowsEnvironmentVariableSystemRoot artifact definition. Creating artifacts like can be done on a case by case basis if needed.\\nThe artifact definition format is described in detail in the Style Guide.\\nEmbed binaries Binaries can be added to pack/bin and than included into the artifactcollector in the go generate step. Additionally a corresponding COMMAND artifact like the following is required.\\nname: Autoruns sources: - type: COMMAND attributes: cmd: autorunsc.exe args: [\\u0026#34;-x\\u0026#34;, \\u0026#34;-accepteula\\u0026#34;] supported_os: [Windows] Currently the output to stdout and stderr is saved, but generated files are not collected.\\n\"","section":"Development","summary":"Forensic investigations differ and investigators have different approaches in forensic cases. The artifactcollector can cater to these needs by collecting a different set of artifacts related to the situation.\nCollect a custom set of artifacts  Clone the repository git clone https://github.com/forensicanalysis/artifactcollector. Run go generate to download all artifacts. Add artifact definition yaml files as needed in pack/artifacts. Do not edit the artifact definitions, as they will be overwritten. Edit pack/ac.","tags":[],"title":"Collect custom artifacts","url":"/documentation/manual/development/customize/"},{"body":"\"Cross compilation is a bit more difficult, as a cross compiler like MinGW is required by CGO.\\nExample cross compilation for Windows:\\nCGO_ENABLED=1 CC=i686-w64-mingw32-gcc GOOS=windows GOARCH=386 go build . CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc GOOS=windows GOARCH=amd64 go build . \"","section":"Development","summary":"Cross compilation is a bit more difficult, as a cross compiler like MinGW is required by CGO.\nExample cross compilation for Windows:\nCGO_ENABLED=1 CC=i686-w64-mingw32-gcc GOOS=windows GOARCH=386 go build . CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc GOOS=windows GOARCH=amd64 go build . ","tags":[],"title":"Cross compilation","url":"/documentation/manual/development/cross/"},{"body":"\"Command types There are three commands types: Built-in Go Commands, Docker Commands or Script Commands.\\nBuilt-in command elementary contains some builtin commands. Those cannot be dynamically extended via plugins.\\nDocker commands Docker commands utilize installed docker images. Those images need to be named xxx/elementary-yyy. elementary loads some image on startup but also handles other images matching the naming schema.\\nScript commands Script commands are rum from the config dir. The config is located at:\\n $XDG_CONFIG_HOME/elementary or $HOME/.config/elementary for Unix systems $HOME/Library/Application Support/elementary on macOS %AppData%/elementary on Windows  The script needs to be prefixed with elementary, e.g. elementary-runkeys.py. elementary installs some scripts on startup but also handles other scripts matching the naming schema.\\n\"","section":"Development","summary":"Command types There are three commands types: Built-in Go Commands, Docker Commands or Script Commands.\nBuilt-in command elementary contains some builtin commands. Those cannot be dynamically extended via plugins.\nDocker commands Docker commands utilize installed docker images. Those images need to be named xxx/elementary-yyy. elementary loads some image on startup but also handles other images matching the naming schema.\nScript commands Script commands are rum from the config dir. The config is located at:","tags":[],"title":"Elementary plugins","url":"/documentation/manual/development/plugins/"},{"body":"\"A forensicstore is a forensic database that contains selected forensic artifacts.\\nThe forensicstore format (version 2) The forensicstore format implements the following conventions:\\n The forensicstore is a sqlite 3 database containing metadata element and compressed raw artifacts. The elements table contains all collected registry keys and values as well as metadata on files, paths, and processes. The files themselves as well as any process output is saved in the sqlar table. Elements are represented as json objects. Elements are valid STIX 2.1 Observable Objects where applicable. Files stored in the forensicstore are referenced by element attributes ending in _path, e.g. export_path, stdout_path and wmi_path. Element attributes ending in _time or named atime, ctime or mtime are assumed to be dates and should be stored according RFC3339/ISO 8601. Any element stored in the forensicstore can have an errors attribute that contains errors that are related to retrival or processing of this element. Raw artifacts are stored using the deflate compression algorithm. Artifacts with a compressed size larger than 1,000,000,000 Byte (1 GB) cannot be stored.  \"","section":"Development","summary":"A forensicstore is a forensic database that contains selected forensic artifacts.\nThe forensicstore format (version 2) The forensicstore format implements the following conventions:\n The forensicstore is a sqlite 3 database containing metadata element and compressed raw artifacts. The elements table contains all collected registry keys and values as well as metadata on files, paths, and processes. The files themselves as well as any process output is saved in the sqlar table.","tags":[],"title":"Forensicstore","url":"/documentation/manual/development/forensicstore/"},{"body":"\"Artifact definition format and style guide Summary This guide contains a description of the forensics artifacts definitions. The artifacts definitions are YAML-based. The format is currently still under development and is likely to undergo some change. One of the goals of this guide is to ensure consistency and readbility of the artifacts definitions.\\nRevision history    Version Author Date Comments     0.0.1 G. Castle November 2014 Initial version.   0.0.2 G. Castle December 2014 Minor format changes.   0.0.3 J.B. Metz April 2015 Merged style guide and artifact definitions wiki page.   0.0.3 J.B. Metz September 2015 Additional label.   0.0.4 J.B. Metz July 2016 Added information about a naming convention.   0.0.5 J.B. Metz February 2019 Removed returned_types as keyword and format changes.   0.0.6-ce J. Plum October 2019 Add information about the knowledge base, directory sources, expansion and globbing    Background The first version of the artifact definitions originated from the GRR project, where it is used to describe and quickly collect data of interest, e.g. specific files or Windows Registry keys. The goal of the format is to provide a way to describe the majority of forensic artifacts in a language that is readable by humans and machines.\\nThe format is designed to be simple and straight forward, so that a digital forensic analysist is able to quickly write artifact definitions during an investigation without having to rely on complex standards or tooling.\\nThe format is intended to describe forensically-relevant data on a machine, while being tool agnostic. In particular we intentionally avoided adding IOC-like logic, or describing how the data should be collected since this varies between tools.\\nTerminology The term artifact (or artefact) is widely used within computer (or digital) forensics, though there is no official definition of this term.\\nThe definition closest to the meaning of the word within computer forensics is that of the word artifact within archaeology. The term should not be confused with the word artifact used within software development.\\nIf archaeology defines an artifact as:\\nsomething made or given shape by man, such as a tool or a work of art, esp an object of archaeological interest The definition of artifact within computer forensics could be:\\nAn object of digital archaeological interest. Where digital archaeology roughly refers to computer forensics without the forensic (legal) context.\\nKnowledge Base The knowledge base is a data store that is used for storing entries about the host, users and other system properties. Every entry maps a key to a list of values e.g.\\n{ \\u0026#34;users.username\\u0026#34;: [\\u0026#34;root\\u0026#34;, \\u0026#34;bob\\u0026#34;], \\u0026#34;users.homedir\\u0026#34;: [\\u0026#34;/root\\u0026#34;, \\u0026#34;/home/bob\\u0026#34;] } It is filled via the provides attribute of sources and can be used in artifact conditions (deprecated) and in parameter expansion.\\nThe artifact definition The best way to show what an artifact definition is, is by example. The following example is the artifact definition for the Windows EVTX System Event Logs.\\nname: WindowsSystemEventLogEvtx doc: Windows System Event log for Vista or later systems. sources: - type: FILE attributes: {paths: [\\u0026#39;%%environ_systemroot%%\\\\System32\\\\winevt\\\\Logs\\\\System.evtx\\u0026#39;]} labels: [Logs] supported_os: [Windows] urls: [\\u0026#39;http://www.forensicswiki.org/wiki/Windows_XML_Event_Log_(EVTX)\\u0026#39;] The artifact definition can have the following values:\\n   Key Description     name The name. An unique string that identifies the artifact definition. Also see section: Name.   doc The description (or documentation). A human readable string that describes the artifact definition. Style note: Typically one line description of the artifact, mentioning important caveats. If more description is necessary, use the Long docs form.   sources A list of source definitions. See section: sources.   labels Optional list of labels. See section: Labels.   supported_os Optional list that indicates which operating systems the artifact definition applies to. See section: Supported operating system.   urls Optional list of URLs with more contextual information. Ideally the artifact definition links to an article that discusses the artificat in more depth.   conditions Deprecated This key should be ignored.   provides Deprecated This key should be ignored.    Name Style note: The name of an artifact defintion should be in CamelCase name without spaces.\\nNaming convention for artifact definition names:\\n Prefix platform specific artifact definitions with the name of the operating system using \\u0026ldquo;Linux\\u0026rdquo;, \\u0026ldquo;MacOS\\u0026rdquo; or \\u0026ldquo;Windows\\u0026rdquo; If not platform specific:  prefix with the application name, for example \\u0026ldquo;ChromeHistory\\u0026rdquo;. prefix with the name of the subsystem, for example \\u0026ldquo;WMIComputerSystemProduct\\u0026rdquo;.    Style note: If the sole source of the artifact definition for example are files use \\u0026ldquo;BrowserHistoryFiles\\u0026rdquo; instead of \\u0026ldquo;BrowserHistory\\u0026rdquo; to reduce ambiguity.\\nLong docs form Multi-line documentation should use the YAML Literal Style as indicated by the | character.\\ndoc: | The Windows run keys. Note users.sid will currently only expand to SIDs with profiles on the system, not all SIDs. Style note: the short description (first line) and the longer portion are separated by an empty line.\\nStyle note: explicit newlines (\\\\n) should not be used.\\nSources Every source definition starts with a type followed by arguments e.g.\\nsources: - type: COMMAND attributes: args: [-qa] cmd: /bin/rpm sources: - type: FILE attributes: paths: - /root/.bashrc - /root/.cshrc - /root/.ksh - /root/.logout - /root/.profile - /root/.tcsh - /root/.zlogin - /root/.zlogout - /root/.zprofile - /root/.zprofile Style note: where sources take a single argument with a single value, the one-line {} form should be used to save on line breaks as below:\\n- type: FILE attributes: {paths: [\\u0026#39;%%environ_systemroot%%\\\\System32\\\\winevt\\\\Logs\\\\System.evtx\\u0026#39;]}    Key Description     attributes A dictionary of keyword attributes specific to the type of source definition.   type The source type.   provides Optional list of dictonaries that describe knowledge base entries that this artifact can supply. See section: Source provides.   supported_os Optional list that indicates which operating systems the artifact definition applies to.   conditions Deprecated Optional list of conditions to when the artifact definition should apply.    Source types Currently the following different source types are defined:\\n   Value Description     ARTIFACT_GROUP A source that consists of a group of other artifacts.   COMMAND A source that consists of the output of a command.   DIRECTORY A source that consists of the file listing of a directories.   FILE A source that consists of the contents of files.   PATH A source that consists of a list of paths.   REGISTRY_KEY A source that consists of the contents of Windows Registry keys.   REGISTRY_VALUE A source that consists of the contents of Windows Registry values.   WMI A source that consists of the output of a Windows Management Instrumentation (WMI) query.    Source provides A source provide defines a knowledge base entry that can be created using this source e.g.\\nsources: - type: PATH attributes: {paths: [\\u0026#39;/Users/*\\u0026#39;]} provides: - key: users.username regex: \\u0026#39;.*/(.*)\\u0026#39; sources: - type: WMI attributes: {query: SELECT * FROM Win32_UserAccount WHERE name=\\u0026#39;%%users.username%%\\u0026#39;} provides: - key: users.userdomain wmi_key: Domain sources: - type: FILE attributes: {paths: [\\u0026#39;/etc/passwd\\u0026#39;]} provides: - key: users.username regex: \\u0026#39;(.*?):.*\\u0026#39; - key: users.homedir regex: \\u0026#39;.*:(.*?):.*\\u0026#39;    Key Description     key Defines the knowledge base key that is provided.   wmi_key Required for provides in WMI sources, disallowed otherwise. WMI object key to select the provided value.   regex Optional regular expression to filter the provided data. The first capturing group defines the provided value.    Provided values are dependend on the source type as follows:\\n   Type Added entries to knowledge base     COMMAND The lines of the stdout of the command.   FILE The lines of the file content.   PATH The defined paths.   REGISTRY_KEY The key paths.   REGISTRY_VALUE The registry values.   WMI The values selected using the wmi_key.    Definition of type ARTIFACT_GROUP or DIRECTORY must not have a provides attribute.\\nArtifact group source The artifact group source is a source that consists of a group of other artifacts e.g.\\n- type: ARTIFACT_GROUP attributes: names: [WindowsRunKeys, WindowsServices] Where attributes can contain the following values:\\n   Value Description     names A list of artifact definition names that make up this \\u0026ldquo;composite\\u0026rdquo; artifact. This can also be used to group multiple artifact definitions into one for convenience.    Command source The command source is a source that consists of the output of a command e.g.\\n- type: COMMAND attributes: args: [-qa] cmd: /bin/rpm Where attributes can contain the following values:\\n   Value Description     args A list arguments to pass to the command.   cmd The path of the command. The path can either be relative or absolute. Handling of relative paths depends on the application processing the artifact.    Directory source The directory source is a source that consists of a file listing of directory contents e.g.\\n- type: DIRECTORY attributes: paths: [\\u0026#39;%%users.userprofile%%\\\\Downloads\\\\*\\u0026#39;] separator: \\u0026#39;\\\\\\u0026#39; Where attributes can contain the following values:\\n   Value Description     paths A list of file paths that can potentially be collected. These paths should be absolute. The paths can use parameter expansion e.g. %%environ_systemroot%%. See section: Parameter expansion and globs   separator Optional path seperator e.g. \\u0026lsquo;' for Windows systems.    File source The file source is a source that consists of the binary contents of files e.g.\\n- type: FILE attributes: paths: [\\u0026#39;%%environ_systemroot%%\\\\System32\\\\winevt\\\\Logs\\\\System.evtx\\u0026#39;] Where attributes can contain the following values:\\n   Value Description     paths A list of file paths that can potentially be collected. These paths should be absolute. The paths can use parameter expansion e.g. %%environ_systemroot%%. See section: Parameter expansion and globs   separator Optional path seperator e.g. \\u0026lsquo;' for Windows systems.    Path source The path source is a source that consists of a list of paths e.g.\\n- type: PATH attributes: paths: [\\u0026#39;\\\\Program Files\\u0026#39;] separator: \\u0026#39;\\\\\\u0026#39; Where attributes can contain the following values:\\n   Value Description     paths A list of file paths that can potentially be collected. These paths can should be absolute. The paths can use parameter expansion e.g. %%environ_systemroot%%. See section: Parameter expansion and globs   separator Optional path seperator e.g. \\u0026lsquo;' for Windows systems.    Windows Registry key source The Windows Registry key source is a source that consists of a key path and all registry values of a Windows Registry key. Subkeys are not part of this artifact.\\nExample:\\nsources: - type: REGISTRY_KEY attributes: keys: - \\u0026#39;HKEY_USERS\\\\%%users.sid%%\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs\\\\*\\u0026#39; Where attributes can contain the following values:\\n   Value Description     keys A list of Windows Registry key paths that can potentially be collected. The paths can use parameter expansion e.g. %%users.sid%%. See section: Parameter expansion and globs    Windows Registry value source The Windows Registry value source is a source that consists of the contents of defined Windows registry values e.g.\\n- type: REGISTRY_VALUE attributes: key_value_pairs: - {key: \\u0026#39;HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Explorer\\\\WindowsUpdate\\u0026#39;, value: \\u0026#39;CISCNF4654\\u0026#39;} Where attributes can contain the following values:\\n   Value Description     key_value_pairs A list of Windows Registry key paths and value names that can potentially be collected. The key path can use parameter expansion e.g. %%users.sid%%. See section: Parameter expansion and globs    Windows Management Instrumentation (WMI) query source The Windows Management Instrumentation (WMI) query source is a source that consists of the output of a Windows Management Instrumentation (WMI) query e.g.\\n- type: WMI attributes: query: SELECT * FROM Win32_UserAccount WHERE name=\\u0026#39;%%users.username%%\\u0026#39; Where attributes can contain the following values:\\n   Value Description     query The Windows Management Instrumentation (WMI) query. The query can use parameter expansion e.g. %%users.username%%. See section: Parameter expansion and globs   base_object Optional WMI base object e.g. winmgmts:\\\\root\\\\SecurityCenter2    Supported operating system Since operating system (OS) conditions are a very common constraint, this has been provided as a separate option supported_os to simplify syntax. For supported_os no quotes are required. The currently supported operating systems are:\\n Darwin (also used for Mac OS X) Linux Windows  supported_os: [Darwin, Linux, Windows] Labels Currently the following different labels are pre-defined:\\n   Value Description     Antivirus Antivirus related artifacts, e.g. quarantine files.   Authentication Authentication artifacts.   Browser Web Browser artifacts.   Cloud Storage Cloud Storage artifacts.   Configuration Files Configuration files artifacts.   Execution Contain execution events.   External Media Contain external media data or events e.g. USB drives.   KnowledgeBase Artifacts used in knowledge base generation.   Logs Contain log files.   Memory Artifacts retrieved from memory.   Network Describe networking state.   Processes Describe running processes.   Software Installed software.   System Core system artifacts.   Users Information about users.    Additional lables are allowed.\\nStyle notes Artifact definition YAML files Artifact definition YAML filenames should be of the form: \\u0026hellip;. $FILENAME.yaml \\u0026hellip;.\\nWhere $FILENAME is name of the file e.g. windows.yaml.\\nEach defintion file should have a comment at the top of the file with a one-line summary describing the type of artifact definitions contained in the file e.g.\\n# Windows specific artifacts. Lists Generally use the short [] format for single-item lists that fit inside 80 characters to save on unnecessary line breaks:\\nlabels: [Logs] supported_os: [Windows] urls: [\\u0026#39;http://www.forensicswiki.org/wiki/Windows_XML_Event_Log_(EVTX)\\u0026#39;] and the bulleted list form for multi-item lists or long lines:\\npaths: - \\u0026#39;HKEY_USERS\\\\%%users.sid%%\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\\u0026#39; - \\u0026#39;HKEY_USERS\\\\%%users.sid%%\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce\\\\*\\u0026#39; - \\u0026#39;HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run\\\\*\\u0026#39; - \\u0026#39;HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnce\\\\*\\u0026#39; - \\u0026#39;HKEY_LOCAL_MACHINE\\\\Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\RunOnceEx\\\\*\\u0026#39; Quotes Quotes should not be used for doc strings, artifact names, and simple lists like labels and supported_os.\\nPaths and URLs should use single quotes to avoid the need for manual escaping.\\npaths: [\\u0026#39;%%environ_temp%%\\\\*.exe\\u0026#39;] urls: [\\u0026#39;http://www.forensicswiki.org/wiki/Windows_XML_Event_Log_(EVTX)\\u0026#39;] Double quotes should be used where escaping causes problems, such as regular expressions:\\ncontent_regex_list: [\\u0026#34;^%%users.username%%:[^:]*\\\\n\\u0026#34;] Minimize the number of definitions by using multiple sources To minimize the number of artifacts in the list, combine them using the supported_os and conditions attributes where it makes sense. e.g. rather than having FirefoxHistoryWindows, FirefoxHistoryLinux, FirefoxHistoryDarwin, do:\\nname: FirefoxHistory doc: Firefox places.sqlite files. sources: - type: FILE attributes: paths: - %%users.localappdata%%\\\\Mozilla\\\\Firefox\\\\Profiles\\\\*\\\\places.sqlite - %%users.appdata%%\\\\Mozilla\\\\Firefox\\\\Profiles\\\\*\\\\places.sqlite supported_os: [Windows] - type: FILE attributes: paths: [%%users.homedir%%/Library/Application Support/Firefox/Profiles/*/places.sqlite] supported_os: [Darwin] - type: FILE attributes: paths: [\\u0026#39;%%users.homedir%%/.mozilla/firefox/*/places.sqlite\\u0026#39;] supported_os: [Linux] labels: [Browser] supported_os: [Windows, Linux, Darwin] Parameter expansion and globs Parameter expansion Path, keys, key and query attributes can contain parameter expansion and globing. This allows for flexible creation of artifact locations.\\nParameter expansions values are enclosed by double percent symbols e.g. %%environ_systemroot%%. The parameter expansion value can be replaced by the corresponding value from the knowledge base.\\nFor every expansion that is used in an artifact, there should be another artifact that provides this expansion in one of its sources. Implementations may choose to precompute parameter values from sources outside of these definitions.\\nParameter Globs Parameters can also contain regular glob elements (**, or *). For example, having files foo, bar, baz glob expansion of ba* will yield bar and baz. A recursive component (specified as **) matches any directory tree up to some specified depth (3 by default). ** does not match the current directory. The search depth can optionally be specified by appending a number, e.g. **9 will match up to 9 levels of a directory hierarchy.\\n\"","section":"Development","summary":"Artifact definition format and style guide Summary This guide contains a description of the forensics artifacts definitions. The artifacts definitions are YAML-based. The format is currently still under development and is likely to undergo some change. One of the goals of this guide is to ensure consistency and readbility of the artifacts definitions.\nRevision history    Version Author Date Comments     0.0.1 G. Castle November 2014 Initial version.","tags":[],"title":"Artifact definition format and style guide","url":"/documentation/manual/development/style_guide/"},{"body":"\"\"","section":"Home","summary":"","tags":[],"title":"Categories","url":"/documentation/categories/"},{"body":"\"\"","section":"Home","summary":"","tags":[],"title":"Print View","url":"/documentation/print/"},{"body":"\"\"","section":"Home","summary":"","tags":[],"title":"Tags","url":"/documentation/tags/"}]